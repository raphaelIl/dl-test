## 리소스 환경별 최적 설정 비교

| 환경 사양 | MAX_WORKERS | 최대 파일 크기 | 동시 다운로드 시나리오 | 비고 |
|---------|-------------|--------------|-------------------|------|
| 1코어 1GB | 2 | 300MB | 1개 대용량(250MB) + 1개 쇼츠(50MB) | 최소 환경에서 안정적 운영 가능 |
| 1코어 2GB | 3 | 750MB | 1개 대용량(500-700MB) + 2개 쇼츠(각 50MB) | 현재 설정, 일반적 사용 패턴에 충분 |

## 워크로드 패턴 분석

| 환경 사양 | 사용 패턴 | 메모리 사용량 (예상) | 성능 영향 |
|---------|---------|-------------------|--------|
| 1코어 1GB | 모두 대용량 | ~750MB (250MB × 3) | 불안정, 메모리 부족 위험 |
| 1코어 1GB | 혼합 패턴 | ~350MB (250MB + 50MB × 2) | 안정적 작동 가능 |
| 1코어 2GB | 모두 대용량 | ~1.5GB (500MB × 3) | 가능하나 시스템 부하 증가 |
| 1코어 2GB | 혼합 패턴 | ~700MB (500MB + 100MB × 2) | 안정적 작동 |

## 권장 사항

| 환경 사양 | 권장 설정 | 근거 |
|---------|---------|-----|
| 1코어 1GB | MAX_WORKERS=2 | 혼합 워크로드 패턴 가정, 메모리 제약 고려 |
| 1코어 2GB | MAX_WORKERS=3 | 현재 설정 유지, 일반적인 사용 패턴에 적합 |

### 근거
테이블에서 권장한 300MB는 다음과 같은 이유로 설정했습니다
* 시스템 오버헤드 고려: 1GB 서버에서 OS와 기본 애플리케이션이 약 200-300MB를 사용합니다.
* 다운로드 과정의 메모리 소비: 실제 파일 크기 외에도 Python, Gunicorn, yt-dlp가 추가 메모리를 소비합니다.
* 안정성 버퍼: 메모리 부족 상황을 방지하기 위한 여유 공간이 필요합니다.

1코어 1GB 환경에서 최대 파일을 500MB로 설정할 경우


* 단일 다운로드: 500MB 파일 처리 + 애플리케이션/OS 오버헤드(300MB) = 800MB 이상
* 2개 동시 다운로드 시: 500MB × 2 + 오버헤드 = 메모리 부족 발생  

최대 파일 크기 300MB는 실제 테스트와 경험적 데이터에 기반한 안정적인 설정입니다. 물론 워크로드가 예측 가능하고 실제 환경에서 문제가 없다면 MAX_FILE_SIZE를 400MB 정도까지 늘릴 수도 있습니다.
